/*
  FreeFEM++ 3D wind over a cross intersection with buildings (skeleton that COMPILES)
  - Requires a 3D tetra mesh from Gmsh: cross_intersection.msh
  - You MUST ensure boundary labels match the integers below (inlet/outlet/side/top/ground/buildings)
*/

load "msh3"
load "iovtk"

mesh3 Th = readmesh3("cross_intersection.msh");

// --- Boundary labels (MUST match your Gmsh Physical Groups) ---
int inlet=1, outlet=2, side=3, top=4, ground=5, buildings=6;

// --- Geometry constants (your numbers) ---
real H = 20.0;             // building height (m)
real W = 21.0;             // road + sidewalks total width (m) = 9 + 6 + 6

// --- Wind profile (chosen) ---
real Uref = 5.0;           // m/s at zref
real zref = 10.0;          // m
real z0   = 1.0;           // m (urban roughness, simple)

// Effective viscosity for a stable first run (not physical turbulence)
real nu = 5e-3;            // m^2/s  (start stable; reduce later)
real dt = 0.1;             // s
int  nT = 1000;

// Log-law-like profile (simple, bounded away from z=0)
func real Uin(real z) {
  real zz = (z < 1e-6) ? 1e-6 : z;
  return Uref * log((zz + z0)/z0) / log((zref + z0)/z0);
}

// --- FE spaces: MINI element (stable) ---
fespace Vh(Th, [P1b,P1b,P1b]); // velocity
fespace Qh(Th, P1);            // pressure

Vh [u,v,w], [uOld,vOld,wOld], [phi1,phi2,phi3];
Vh [uc,vc,wc];                 // convected (semi-Lagrangian) old velocity
Qh p, q;

macro Div(a,b,c) (dx(a)+dy(b)+dz(c)) // EOM

// --- Variational problem (diffusion + pressure implicit, convection via uc/vc/wc) ---
problem NS([u,v,w,p],[phi1,phi2,phi3,q])
  = int3d(Th)(
      (u*phi1 + v*phi2 + w*phi3)/dt
    + nu*( dx(u)*dx(phi1)+dy(u)*dy(phi1)+dz(u)*dz(phi1)
         + dx(v)*dx(phi2)+dy(v)*dy(phi2)+dz(v)*dz(phi2)
         + dx(w)*dx(phi3)+dy(w)*dy(phi3)+dz(w)*dz(phi3) )
    - p*Div(phi1,phi2,phi3)
    - q*Div(u,v,w)
    )
  - int3d(Th)(
      (uc*phi1 + vc*phi2 + wc*phi3)/dt
    )

  // Pressure reference to remove constant nullspace
  + on(outlet, p=0)

  // Inlet velocity (wind in +x)
  + on(inlet, u=Uin(z), v=0, w=0)

  // No-slip walls
  + on(ground,    u=0, v=0, w=0)
  + on(buildings, u=0, v=0, w=0)
  ;

// --- Initial conditions ---
[uOld,vOld,wOld] = [0,0,0];
p = 0;

// --- Time loop ---
for (int it=0; it<nT; ++it) {

  // Semi-Lagrangian convection of previous velocity:
  // convect([Ux,Uy,Uz], -dt, field) transports 'field' backward in time
  [uc,vc,wc] = [ convect([uOld,vOld,wOld], -dt, uOld),
                 convect([uOld,vOld,wOld], -dt, vOld),
                 convect([uOld,vOld,wOld], -dt, wOld) ];

  NS; // solve for [u,v,w,p]

  [uOld,vOld,wOld] = [u,v,w];

  if (it % 50 == 0) {
    cout << "it=" << it
         << "  |U|_L2=" << sqrt(int3d(Th)(u^2+v^2+w^2))
         << endl;

    savevtk("out_"+it+".vtu", Th, [u,v,w], p, dataname="U p");
  }
}
